ğŸ“ŒğŸ“Œ
vite = 5173

 express = 5000

 optionalProxy = 8080 (Optional/Configurable)

 cra = 3000 	(CRA or Legacy Projects) (Mostly not Mandatory)
________________________________________________________________________________________
http://localhost:8080/ ğŸ˜ğŸ˜ğŸ˜ğŸ˜ğŸ˜ğŸ˜ğŸ˜ğŸ˜ğŸ˜ğŸ˜ğŸ˜ğŸ˜ğŸ˜ğŸ˜ğŸ˜ğŸ˜ğŸ˜ğŸ˜ğŸ˜ğŸ˜ğŸ˜ğŸ˜ğŸ˜ğŸ˜
// BACKEND BACKEND  BACKEND BACKEND BACKEND BACKEND BACKEND BACKEND BACKEND BACKEND BACKEND BACKEND BACKEND BACKEND BACKEND BACKEND BACKEND BACKEND BACKEND BACKEND BACKEND BACKEND  BACKEND BACKEND BACKEND BACKEND BACKEND BACKEND BACKEND BACKEND BACKEND BACKEND BACKEND BACKEND BACKEND BACKEND BACKEND BACKEND BACKEND BACKEND 
http://localhost:8080/
________________________________________________________________________________________
ğŸ“ŒğŸ“Œ
________________________________________________________________________________________
// added 5 folders besides basic(config folder containing db-connect file) for mvc of web-app

// keep the separation of concerns, like helpers(or utils), routes, controllers, models, middlewares ğŸ‘€  (5) essentials..

________________________________________________________________________________________
ğŸ“ŒğŸ“Œ
// MODEL ________________________________________________________________________________________________
________________________________________________________________________________________
// we create a model, 1st one is userModel where we define userSchema (for new website visitors tracing), and saving to database

________________________________________________________________________________________
ğŸ“ŒğŸ“Œ
// ROUTE _______________________________________________________________________________________________
________________________________________________________________________________________
// we create routes, 1st is auth Route (for new users ), for proper app routing the new users data to database(creating route through ExpressJS)

// as we following mvc, ğŸ˜

________________________________________________________________________________________
ğŸ“ŒğŸ“Œ
// CONTROLLER ________________________________________________________________________________________
________________________________________________________________________________________
// we create controllers for routing , 1st is (authController), authController will contain register, login ...

________________________________________________________________________________________
ğŸ“ŒğŸ“Œ
// HELPER __________________________________________________________________________________________
________________________________________________________________________________________
// we will now create a Helpers, (1st is authHelper) for functions like registration, passcode encryption/hashing and comparison

// registration api working, mongoDB and allğŸ“Œ

// but now we secure app using JSON web tokenğŸ™

// jwt ( JSON web token) will provide token (custom/self written jwt-secret) during login, 

// so during-login, password decrypted(un-hased #) (loginController decrypt password) and token provided(with expiry if there)

// login api working, mongoDB and allğŸ“Œ

// for jwt sake and usage,

________________________________________________________________________________________
ğŸ“ŒğŸ“Œ
// MIDDLEWARE ___________________________________________________________________________________________________
________________________________________________________________________________________
// we create middleware(s) to protect every other route, after register and login, like requireSignIn(for decrypt TOKEN and checking in every route request except register/login), 

// create second middleware isAdmin(for checking ADMIN privileges)

________________________________________________________________________________________
ğŸ“ŒğŸ“Œ
http://localhost:3000/ ğŸ˜ğŸ˜ğŸ˜ğŸ˜ğŸ˜ğŸ˜ğŸ˜ğŸ˜ğŸ˜ğŸ˜ğŸ˜ğŸ˜ğŸ˜ğŸ˜ğŸ˜ğŸ˜ğŸ˜ğŸ˜ğŸ˜ğŸ˜ğŸ˜ğŸ˜ğŸ˜ğŸ˜
// FRONTEND FRONTEND FRONTEND FRONTEND  FRONTEND FRONTEND FRONTEND FRONTEND  FRONTEND FRONTEND FRONTEND FRONTEND  FRONTEND FRONTEND FRONTEND FRONTEND  FRONTEND FRONTEND FRONTEND FRONTEND  FRONTEND FRONTEND FRONTEND FRONTEND  FRONTEND FRONTEND FRONTEND FRONTEND  FRONTEND FRONTEND  FRONTEND FRONTEND FRONTEND FRONTEND  FRONTEND FRONTEND
http://localhost:3000/
________________________________________________________________________________________
________________________________________________________________________________________

// (MUST) add bootstrap 5 to frontend/public/index.html ğŸ˜

// (MUST) remove all css (eg. app.css, index.css) (i.e Globally index. and very-first Component-App.)

// (MUST) add css (index.css - i.e. global) as the (backend has server.js && frontend has index.js)

// note: browser sees index.html (as browser requests/receives index.html) WEBPACK-ğŸ‘€ injects automatically <script> tag for index.js to index.html (DURING BUILD PROCESS) 

// create components and pages folder -------------------------
// pages would have navigations, routing, ....................

// 1st component- LAYOUT.JS (app.js is 1st but given to us, so assume it 0th component(app.js)ğŸ“Œ) (consume header && footer in Layout component for later use)
________________________________________________________________________________________
ğŸ“ŒğŸ“Œ
// FRONTEND - props (----------------------------know-how)
________________________________________________________________________________________
________________________________________________________________________________________

// props spelling not must to be correct, it's just an objectğŸ˜… (it can be porps, popcorn)

// create a layout component with header and footer, (LAYOUT COMPONENT FOR FLEXIBILITY eg. header, footer and later in future->sidebar)

// WORKING 1st define component with prop e.g... const MyComponent = (props) => { // ...}; (PROPS PARAMETER IS AN OBJECT)

// USAGE 2nd use component with props e.g... <MyComponent msg="Hello" name="Rohit"/> // // Inside MyComponent, the props object will be 
    {
    msg:"Hello",
    name:"Rohit"
    }

// children (i.e. as in props.children) is a SPECIAL PROP, Layout component is parent, and whatever in between that would be children automatically

// {obj} DESTRUCTURING allows to unpack properties/keys (obj=key-value pair) from {ojb} into vars

// so, children is special prop, and whatever regular props have to define can be destructured along this special prop, e.g
// const Layout = ({ children, showFooter }) 
// showFooter is regular prop 

//   <Layout showFooter={true}>
//        <h1>Page 1 Content</h1>
//   </Layout>
________________________________________________________________________________________

// mern app = spa(single page app) so routing(i.e react-router-dom package) necessaryğŸ“Œ

// use BrowserRouterğŸ˜ƒ i.e from rectroutDOM, (main file - index.js)

// create different pages, (i.e. home, about, contact, ... wrapped in our LAYOUT)

// remove 0th component(app.js) <h1>Ecomm app</h1> 
// i.e.   <Layout>
// <h1>Ecommerce App</h1>
//  </Layout>

// import Routes, Route for app.js along with nav links to pages
________________________________________________________________________________________
ğŸ“ŒğŸ“Œ
// FRONTEND - router (----------------------------know-how)
________________________________________________________________________________________
________________________________________________________________________________________
// use Routes as CONTAINER, and Route for specificity(subjects-pages)

// use paths along their elements...
// eg. path="/" element={<HomePage />}, path="/about" element={<About/>} etc.

// use  <Route path="*" element={<Pagenotfound />} /> (AFTER ALL ROUTE) ğŸ˜ğŸ˜ğŸ˜ for everything

// BECAUSE âœ… 200 - success, ğŸ” 300 - redirects, âŒ 400 - client errors, ğŸ’¥ 500 -server errors
// â„¹ï¸ 100 - informational (i.e. 100 continue- client can continue with request, 101 Switching Protocols- Protocol change (eg. HTTP to WebSocket))etc.
________________________________________________________________________________________

// DESIGN--  RE-Design (header, footer)

// visit getbootstrap.com (for CSS - header-navbar)

// Now, in place of anchor(<a>), Usage of NavLink (from REACT ROUTER DOM) take place...

// After pasting any boilerplate code or little template snippets, use COVERT HTML TO JSX, (like for eg. bootstrap navbar) --- ğŸ˜ğŸ˜ Because CLASS changes to CLASS_NAME

// .gitignore in parent(backend folder) ignores /public for backend but not of child-FRONTEND(client/public) using client/public/* && !client/public/robots.txt, !client/public/img

// Style navbar with react icons and link, navlink-to and custom css (ğŸ˜Œlink for internal linking, navlink for beautiful styled links in menus,navs,headers)

// Ensure fonts properly, BOOTSTRAP by default provides- roboto font, FALLBACK(sans-serif) for each fonts use, (import others as required)

// besides REACT -icons, :emojisense: VS-CODE EXTENSION ___ctrl+i eg.shopping cart icon for logo ğŸ›’

// ğŸ’¯ FOOTER - with links 

// after Header, Footer done, on going to pages --> page title not changing (We should make it SEOğŸ’¡ friendly)...

// Currently we not have routes for /category /register /login /cart (where we will show as all other not existing routes, Page not Found )

// GIT COMMANDS, from commits to merging and all..................... GITğŸ (Github DESKTOP app = Focus on what matters instead of fighting with Git) example: use github app for ammending(commit message) and then git push --force (for altering commit in that main repo from where it is cloned)...

// REACT - by default not supports SEO, (third party packages) and other fundamentals for GOOGLE to consider your software to be ranked.... (eg. meta tag)

// so, as Meta tags gets static/hard-coded not dynamic, so React-HELMET (keywords, description)...

// Layout.defaultProps ğŸ•ğŸ•ğŸ• (OBJECTğŸ˜…) for default ones if no props gets passed,  (eg. in layout wrapping each page, title-description && -keywords for whole ecommerce site), or otherwise pass props from each page (100% seo), other packages later...

// issues with React-helmet package, some of good latest packages are react-helmet-asyncğŸœ

// use * instead /* for non exising pages- routes....

// Now Register and other pages like login (rafce - react arrow function with export (VS CODE SNIPPET))

// Register page - FRONTEND

// use bootstrap for register .. & login page template

// ////////////////////////////////////////////////////// Register page /////////////////////////////////////////////
ğŸ“ŒğŸ“Œ
ğŸ“ŒğŸ“Œ
// importing packages in client(frontend) and main directory(backend) differs a little as backend directory - package.json mentioned (type:"module") but
// While We can use the .js extension for local modules in ES6 imports,but many libraries, including JWT, may not require it due to historical reasons and compatibility with older Node.js versions

// Register form termplate from bootstrap-5 docs && then convert HTML to JSX

axios (for http client) & toastify (for notifications) -

cors (for connecting two servers =  ports 8080 && 3000 causing cross - origin conflict) // so cancel errors related to origin

concurrently ( for npm start - both client and server in single command)

------------axios -  `${process.env.REACT_APP_API}/api/v1/auth/register`, ((SEND DATA OF REGISTER FORM TO BACKEND))
--as defined âœ¨in auth route - post register for method, we will send form data to the register controller (i.e to the auth controller) having following::

-------------------------------------
 res.status(201).send({
      success: true,
      message: "User registered successfully",
 })
-------------------------------------

///////////////////////////////////////////////////////  Register page ends //////////////////////////////////////////////////
ğŸ“ŒğŸ“Œ
ğŸ“ŒğŸ“Œ
________________________________________________________________________________________
From now on, just run (npm run dev) for development of both frontend and backend (run in just 1 cli)

npm run dev 

> ecommerce-app-7@1.0.0 dev
> concurrently "npm run server" "npm run client"
________________________________________________________________________________________


________________________________________________________________________________________
ğŸ’€ğŸ’€ğŸ’€
For following error, remove <React.StrictMode> <React.StrictMode> from index.js 

Using UNSAFE_componentWillMount in strict mode is not recommended and may indicate bugs in your code. See https://react.dev/link/unsafe-component-lifecycles for details.

* Move code with side effects to componentDidMount, and set initial state in the constructor.

Please update the following components: SideEffect(NullComponent)
________________________________________________________________________________________


________________________________________________________________________________________
ğŸ’€ğŸ’€ğŸ’€ ğŸ¦ŠğŸ¦ŠğŸ¦ŠğŸ¦Š
For following error,
firefox console showing (UNDEFINED) within post request url !!!
http://localhost:3000/undefined/api/v1/auth/regis

FOR THAT, W-E  A-D-D-E-D  P-R-O-X-Y not normal .env variable
> package.json, add "proxy":"http://localhost:8080
---------------------------------------------------
  "name": "client",
  "proxy": "http://localhost:8080",
________________________________________________________________________________________


________________________________________________________________________________________
ğŸ’€ğŸ’€
react -toastify not showing up 
on success user registatin navigate to login
so - ANOTHER PACKAGE RE-PLACEMENT (react -hot -toast)
________________________________________________________________________________________

________________________________________________________________________________________
ğŸ“ŒğŸ“Œ
created a styles folder in src (of frontend i.e client)
AS INLINE-CSS is OLD, (CAUSES WEBSITE SPEED ISSUES)
we created authStyles css file for forms-authPages
________________________________________________________________________________________

________________________________________________________________________________________
ğŸ“ŒğŸ“Œ
after login form -> html && css
controller already setup (setup already done)
route already setup (setup already done)
________________________________________________________________________________________

________________________________________________________________________________________
ğŸ“¢ğŸ“¢ğŸ“¢ğŸ“¢
We will use CONTEXT API for this project, not redux-toolkit

Nothing to install, react already provides CONTEXT (function(i.e hooks) based, )

let's create CONTEXT
________________________________________________________________________________________
â“â“â”â”
unpredicted - Login page getting css automatically without explicitly defining import "../../styles/AuthStyles.css";

(ğŸŒŸ CONTEXT-APi + LOCAL-Storage ---> SURVIVES REFRESH___________)
Ok, now STORE LOGIN credentials to -> CONTEXT API -> LOCAL STORAGE, before homepage redirect

--- after some chat gpting;ğŸ’€ğŸ’€ğŸ’€
i got to know = Because CSS is global in React unless scopedğŸš‘ğŸš‘ğŸš‘

-- so thing to always remember (css is global in react unless -- css modules for scoped styling or just have css imports in app.js - laziness at extreme)
// for now, moving that css import to app.js (to showcase, it is done as per intention- sharing to both form pages)

// key note: to keep styles isolated to a single component,, IT OUGHT TO USE - css modulesğŸš‘ğŸš‘
________________________________________________________________________________________

________________________________________________________________________________________
ğŸ’¡ğŸ’¡ğŸ’¡
So, to persist Context API state across page refreshes,  (login - credentials)
we explicitly stored and retrieved data using client-side storage (LOCAL STORAGE)

after 1st login redirect- >>>>SET_AUTH of Login-page works until refresh<<<<<<, then on refresh(homepage refresh, so did our CONTEXT API CODE calling LOCAL-STORAGE for Login-credentials)
________________________________________________________________________________________

________________________________________________________________________________________
âš¡ğŸ’€âš¡âš¡â”â“â“
 error:
 Maximum update depth exceeded. This can happen when a component calls setState inside useEffect, but useEffect either doesn't have a dependency array, or one of the dependencies changes on every render.

 in context api folder (nested in src folder of frontend), auth.js for (context api- global storage for login credentials), I got provided with knowledge to use (auth, setAuth)

 but error gone after removing [auth] from dependency array, as it is triggering infinite loop.

 what i know: blank dependency array run once.
 what i got to know(this error): We are initializing state from localStorage, so there's no need to watch auth for changes.

 // then i discovered (which exists, but i not found yet, or my small brain not catched)

 for cancelling linter (e.g eslint) issues (we done that)
âœ… // eslint-disable-next-line

which only & only applies to the very next line
// that prevented eslint warning ---
----------------------------------------- for example below
useEffect(() => {
  console.log(auth);                // <-- used here
}, []);                             // <-- not included here
---------------------------------------------
As, eslint says:
ESLint says:
âš ï¸ React Hook useEffect has a missing dependency: 'auth'. Either include it or remove the dependency array.

//now question arises
// â“ But Why Does This Matter?
// âœ”â˜‘âœ… Including dependencies ensures the effect always runs with the latest values.

------------ IMAGINE
useEffect(() => {
  if (auth.token) doSomething();
}, []);
---------------
ğŸš‘ğŸš‘ğŸš‘
If auth.token is updated after mount â€” this effect will never re-run, and you'll miss that token change. Thatâ€™s what the ESLint rule is trying to prevent. (T-O-K-E-NğŸ™)
 ________________________________________________________________________________________

 ________________________________________________________________________________________
ğŸ†ğŸ†ğŸ†
ğŸ¥‡ğŸ¥‡ğŸ¥‡
LIVE PROJECT WORKING ON THIS STATE, THE FRONTEND IS IN THE VERCEL, THE BACKEND IS IN THE RENDER, OTHER FREE BACKEND DEPLOYMENT OPTIONS Currently
NOT FREE / E.G CYCLIC, RAILWAY, (RAILWAY DOES PROVIDES SOME FREE TIER BUT FOR SOMETIME, AFTER THAT IT ALSO STOPS WORKING)

// A FACT:
ğŸš« Don't use import.meta.env unless you're using Vite. (as Render - free backend DEPLOYMENT also runs using process.env for dynamic url for cra apps)
________________________________________________________________________________________
________________________________________________________________________________________

ğŸ”¥ğŸ”¥ğŸ”¥making use of a variable (for making both frontend and backend work)
  const API =
    process.env.NODE_ENV === "production" ? process.env.REACT_APP_API : "";

    using in register/login for (working on both local machine and at production without mis-configuring anything, (frontend using proxy(in package.json stating backend url - http://localhost:8080) so, not need for url))

    ğŸ§­ğŸ§­ğŸ§­(the magician here) = process.env.NODE_ENV
This is automatically injected by React Scripts (from react-scripts) to tell the app which mode it's running in:
--------------------------------------------------------
"development" â€” when you run npm start

"production" â€” when you run npm run build
________________________________________________________________________________________
________________________________________________________________________________________
ğŸğŸğŸ
not console logs in production (to prevent cluttering)
or
lowering user experience
________________________________________________________________________________________

________________________________________________________________________________________
create a user dashboard page;;; 
i.e user page -> dashboard 

// then a new Component(2nd component = Routes) = components -> Routes(Private.js) (i.e a private component after routing passing all checks of protected route), (1st component = Layout is generic one for scaffolding every page as we know-desinging purpose)

// for nested routing
-- we use <OUTLET> (react-router-dom)
________________________________________________________________________________________

________________________________________________________________________________________
then,
 include axios header(which we trying to do in - GLOBAL (i.e CONTEXT API))
 // we set axios defaults, not app-BASE-URL for now, but axios requests headers
 // axios.defaults.headers.common['Authorization'] = auth?.token;
 ---- 2nd component(Routing, 1st one is LAYOUT) ->private.js -- for token-checks, auth-checks
 ----- that also recalls of that useEffect dependencies check -i.e OUGHT TO INCLUDE token-checks variable e.g auth?.token to dependency array [], // the EDGE-cases es-linter tries to prevent

 i.e do the following globally (not repetitive - kind of like programmatic seo - bots fills data on every creation without 
 seo persons intervention)
-------------------------------------
  headers: {
          Authorization: auth?.token,
        },
---------------------------------------
   // the auth?.token works behind the scenes as conditionally executing further code - after auth only if yes
  // (i.e if auth then only auth.token - By condition(auth?.token))

Now, we can remove the 2nd objectğŸ˜…

Before:
  const res = await axios.get(`${API}/api/v1/auth/user-auth`, { headers: { Authorization: auth?.token } });

After:
  const res = await axios.get(`${API}/api/v1/auth/user-auth`, );
  const res = await axios.get(`${API}/api/v1/auth/user-auth`);
________________________________________________________________________________________

________________________________________________________________________________________
get spinner, (get.BootstrapğŸ˜ƒ), 
for now, we are using --- ----- rotating ring spinner

// just out of curiosity:
/// 2 spinners in (get bootstrap)
------------------------------
.spinner-border â€” the rotating ring

.spinner-grow â€” the pulsating grow spinner
-------------------------------
we will go for Placement (for that .spinner-border) 
for: Use flexbox utilities, float utilities, or text alignment utilities to place spinners exactly where you need them in any situation.
________________________________________________________________________________________

________________________________________________________________________________________
ğŸ“ŒğŸ“Œ
3rd component - spinner 
copy bootstrap (.spinner-border -> Placement) 
then convert html->JSX
________________________________________________________________________________________

________________________________________________________________________________________
ğŸ“ğŸ“
Private Route in action (2nd component magic)

(within App.js)
Before:
 <Route path="/dashboard" element={<Dashboard />} />

 After:
   <Route path="/dashboard" element={<PrivateRoute/>}>
              <Route path="" element={<Dashboard />} />
   </Route>
________________________________________________________________________________________

________________________________________________________________________________________
now,
in 3rd component(Spinner), add logic (to not just show infinite looping animation - circle spinning)

useNavigate
useState
useEffect - No useEffect(() => {}) --- it will run on every render (one of worst cases..), array(dependency array[]) even if it is blank, tells to not re-run it on updates
ğŸ‰ğŸ‰
but for now, we are using useEffect (without condition-checks i.e auth?.token or execute further only if it is presence) and passing 2 values to dependency array [count, navigate] 
---- Long live Spinner.js (a very good component!!!)
________________________________________________________________________________________

________________________________________________________________________________________
ğŸ›ºğŸ›º
Accidentally, clicked INS key (secondary keyboard i am using for programming)
---------------------------------
VS Code, like many text editors, supports two modes:

1. Insert Mode (ğŸŸ¢ default): text is inserted at the cursor.
2. Overwrite Mode (ğŸ”´ problem): new text replaces existing text at the cursor.
----------------------------------
Pressed INS again, and the problem is gone...
________________________________________________________________________________________

________________________________________________________________________________________
in 3rd component(spinner.js)
which contains logic as of now, for redirecting to login (if trying to access protected /dashboard), & dashboard(for loged in users)

reduced 5 seconds -> 3 seconds (the time website assumes good to reduce users bouce rate, time after which users exits site)
________________________________________________________________________________________

________________________________________________________________________________________
ğŸ“ŒğŸ“Œ
now User -experience (implement user location history, where does user navigating or trying -- kind of navigational keywords in google(eg. gov schemes, 
--company --service, pizza domminos))
-- why benefit?
assume, user has saved some product in cart,, or maybe he/she has a link(e.g checkout)
so if he/she login -> and our app throw him/her to homePage then user get confused(is it a good navigation, or my device problem)

spinner.js = access route from url(even if it is un-authorized, we re-direct it to /login, then on login-success, re-direct to /route they want to access )
// Destination without showcasing home-page un-necessarily 
âœ¨âœ¨useLocation hook (from 'react-router-dom')
________________________________________________________________________________________

________________________________________________________________________________________
âš¡âš¡âš¡useLocation ...
the hook, not changes the spinner.js useEffect's dependency array vars from [count, navigate] to [count, navigate, location]

and also, LOGIN.js ---- no more just 
navigate('/') on formSubmit function, it get conditional - checks (some dynamics)
________________________________________________________________________________________

________________________________________________________________________________________

// let's create FORGOT-PASSWORD FUNCTIONALITYğŸ¨ğŸ¨
add some secret key in model(i.e userModel) - like question; (question naming is confusing, so finally- answer)

create new END-POINT
in authRoute.js -> forgotPassword

But as per naming conventions and confustion prevention = question->answer... (change that key naming in the user model)
added -> authController ->forgotPassword()

now, give page(Register.js) the forgotPassword functionality (new field during register = answer);
// question chosen for filling up answer value = What is your favourite sports
now, give page(login.js) -> forgot password button below login button

now, create new auth page(just like login/register) -> forgotPassword.js
and then route to that auth page(forgotPassword) inside APP.JS

then, add that answer-> authController -> registerController(the 1st controller user form filling logic)
________________________________________________________________________________________

________________________________________________________________________________________
// some forgot-password form error
so removed client= frontend(package.json statement)
 "proxy": "http://localhost:8080",

 instead of that, we manually added; http://localhost:8080 to each forms- register, login, forgot-password
âœ… CORS is a backend-only configuration.
so, we added to main backend file -> both origins(local:3000 and prod:vercel.com..)

error caught: mistakenly  destructuring req.body as an array using [] but req.body is a JSON object, (so values becomes undefined)ğŸ˜¬
&& also another mistake, 1 more cors config below the 0th cors config causing backend crash(i.e app.options("*", cors());),

key note: Postman(for e.g using body â†’ raw â†’ JSON) doesn't care about CORS â€” but browser does(chrome, firefox running R-E-A-C-T)..
key note: âœ… Ensure backend allows CORS from frontend
key note: keep only 1 cors in backend for preventing unknown issues...(2 cors = backend crashes, tested)
 ________________________________________________________________________________________

 ________________________________________________________________________________________
 ğŸ”ğŸ”
postman running perfect
https://ecommerce-app-7-q9em.onrender.com/api/v1/auth/forgot-password
http://localhost:8080/api/v1/auth/forgot-password

but in front-ends (local and prod), getting post 404 not found errors...

Key note: having anything like (res.status(anything).send() e.g anything = 404 ) causes confusion so, even if status code
// are used without putting brain strain, even keep response.data.message something logical so, one can get illusion
// 404 not found( but still open up error-> response-> data)âœ¨âœ¨

// the following message saved hours, wrong http status code by coders
  // validation
    if (!user) {
      return res.status(404).send({
        success: false,
        message: "Wrong Email or Answer",
      });
    }
________________________________________________________________________________________

________________________________________________________________________________________
âœ¨ 
role base authentication
 ğŸ’€ğŸ’€
for roles, have a dropdown (so get bootstrap)
ul inside li (i.e <li><ul>...</ul></li>)
// all basic FUNCTIONALITYğŸ¨ğŸ¨ DONE, so we will now keep 2 dashboard - different for each role

// Now, we will work on dashboard
// 1st user dashboard (private.js)
// 2nd admin dashboard (also will connect it as same as protected route(private.js) orğŸ‰ will copy Private.js->AdminRoute.js)- part of 2nd Component(for routing users and admins)

// Change role manually (i.e) -> we registered a user named as ADMIN
// and every user by default role(0)

// so going to mongoDB compass, change 0 to 1;

// now, creat-new one like, since pages -> user(i.e Dashboard.js),
hence pages -> admin(i.e AdminDashboard.js);

// create route for this(eg. route.get or post(__'/slug or id', handler__) ),, ->authRoute.js(having login, register, normalUser auth...)

// USER = normal user, ADMIN = power user;ğŸğŸğŸ­ğŸ­

so just like(normal user auth) route: router.get("/user-auth", requireSignIn, (req
create(power user auth)route: router.get("/user-auth", requireSignIn, (req

i.e.
/////// copy- user
 <Route path="/dashboard" element={<PrivateRoute />}>
          <Route path="user" element={<Dashboard />} />
        </Route>

/////// paste- admin
 <Route path="/dashboard" element={<AdminRoute />}>
          <Route path="admin" element={<AdminDashboard />} />
        </Route>

--------------------------- &&
[{(Header.js)}] + also pass role during (login.js) form submission 

// based on App.js before & after(paths i.e user and admin) as per role, for routing seamlessly
// before: 
<li>
<NavLink className="dropdown-item" to="/dashboard">
                          Dashboard
</NavLink>

// after: 
<li>
<NavLink className="dropdown-item" to={`/dashboard/${auth?.user?.role === 1? 'admin':'user'}`}>
                          Dashboard
</NavLink>
---------------------
// NOW The role based authentication completed----------- Header re-directing on click(Dashboard) based on auth.user.role

// in local live changes,,
for user(normal user) -> dashboard triggers = http://localhost:3000/dashboard/user
and for admin(power user) -> dashbord triggers = http://localhost:3000/dashboard/admin
________________________________________________________________________________________

________________________________________________________________________________________
ğŸ‰ğŸ‰ğŸ‰ğŸ‰
Now fix spinner, if user edits intentionally the localhost:3000/dashboard/ (from user-> admin), for which role is not permit

// spinner directs to login page, so send path(i.e user/admin) as prop to it, 
// spinner will now expect (path as prop, also initiate on the spot with value(login))
[i.e destructure path and having initial value of key being passed as prop - we done so, 
because if we not pass any value then it will pass us to login form page] 
and finally add -path to dependency array, 
last but not the least pass- path="" (blank path) to private route(i.e component for user) 
-the users which are editing url manually, 
to make spinner work conditionally, (fixes--)

Fix done: if user(normal user) trying to do localhost:3000/dashboard/admin instead localhost:3000/dashboard/user (manually), so even after login, the spinner takes them to login page.
________________________________________________________________________________________

________________________________________________________________________________________
ğŸ˜ğŸ˜ now user dashboard ui - 2 cols
left side - side bar menu
right side - Content
create new component(functional component named AdminMenu.js) and keep it inside Layout directory of components but keeping separate directory is preferred(4th Component)- 

so, we naming it (4th Component - Menu component -> sub-division(Admin_MENU)= AdminMenu.js)
________________________________________________________________________________________

________________________________________________________________________________________
ğŸ“ŒğŸ“Œ
AdminMenu.js
(by helping of list- we design menus) = so, get bootstrap...(#list group)

Definition of list or list group (bootstrap) = List groups are a flexible and powerful component for displaying a series of content...
Modify and extend them to support just about any content within.

(now, convert html to jsx), also keep entering {CTRL + D}: vs code shortcut, to multiple select all anchor tags automatically,(for NavLink replace)

(for href, the same- keep entering {CTRL + D} for multiple selection, and renaming all href at once)
(and {CTRL + X} to remove the current line in which cursor is in the coding area...)

Now give routing using the NavLink (to="") in the various list group items - for api's inside dashboard/admin like /users, /create-product, /create-category....
________________________________________________________________________________________

________________________________________________________________________________________
Now, AdminDashboard.js ğŸğŸ
use GRID;


{use CTRL + C} to copy current line (cursor is placed to write code)
issue resolved: css issues due to class(keyword) instead of className
issue not getting: auth?.user?.name from context api,,ğŸ¤”ğŸ¤” 
issue resolution:
before: const {auth} = useAuth();
after: const [auth] = useAuth(); 

if we want - const {auth} to work, then use object destructuring, not array destructuring(i.e <AuthContext.Provider value={{ auth, setAuth }}>)
________________________________________________________________________________________

________________________________________________________________________________________
create admin dashboard pages, and routing in app.js

it will become:
 <Route path="/dashboard" element={<AdminRoute />}>
          <Route path="admin" element={<AdminDashboard />} />
          <Route path="admin/create-category" element={<CreateCategory />} />
          <Route path="admin/create-product" element={<CreateProduct />} />/
           <Route path="admin/users" element={<AdminUsers />} />/
        </Route>

// wrap every page with layout component as usual, for styling(headers, nav, footer) and pass title
________________________________________________________________________________________

________________________________________________________________________________________
now, user (normal user) dashboardâœ¨âœ¨
user dashboard - pages will be (profile, orders) - (not/ unlike add admin/create cat./ create prod. )
______________________________________________________________________________

______________________________________________________________________________
now, basic ecommerce:
create products->api->fetch->presentation
ğŸ›’ğŸ›’

let's first, correct (manual url issues), 
the admin route is working fine, routing to homepage if admin manually edit url to user

but user(normal user) on editing url manually gets error then..
so, 
1.) middlewares/ â†’ Contains authMiddleware.js (we'll review this first)
2.) routes/ â†’ Contains authRoute.js (weâ€™ll verify the /admin-auth route)
3.) controllers/ â†’ Contains authController.js etc.

Token storage	âœ… Stored in localStorage as auth.token
Token sending	âœ… Sent in Authorization: Bearer ${token} format
Middleware updated	âœ… requireSignIn now correctly extracts token
isAdmin middleware	âœ… Checks user.role === 1 correctly
AdminRoute frontend	âœ… Redirects normal users (role !== 1)
authCheck()	âœ… Uses Axios with correct headers and state logic
Route protection	âœ… admin-auth uses both requireSignIn and isAdmin
----------------
normal users "role": 0
advanced users(admin) "role": 1
// while 401 is still there, but for admins (on editing url to user manually) also started taking time
______________________________________________________________________________

______________________________________________________________________________
carry on, create products->api->fetch->presentation
ğŸ›’ğŸ›’
Last  UX enhancement: useLocation hook usage in Spinner.js
---------------------
###> User tries to open /dashboard/user (or /dashboard/admin), the normal /dashboard route is homepage redirected...
But theyâ€™re not logged inğŸš€ğŸš€

You redirect them via <Spinner />, and remember where they came from:
âœ… If a user tries to open /dashboard/user or /dashboard/admin without being logged in, they get redirected to /login, and
âœ… After login, they are sent back to where they originally intended to go.
 // Redirect based on:
      // 1. Previous location (anything other than /dashboard routes)
      // 2. User role fallback
      if (location.state) {
        navigate(location.state);
      } else if (userRole === 1) {
        navigate("/dashboard/admin");
      } else {
        navigate("/dashboard/user");
      }
---------------------
// CREATE new model for categoryğŸ“ŒğŸ“Œ 
// models->categoryModel.js(2nd model) (i.e 1st model is userModel- users task is over)
ğŸ’¾ğŸ’¾
new package (slugify), we will use hypen/dash instead underscore (package correctly installed in node server)
------------
then // routes ->categoryRoute.js (2nd route)
then // controllers ->categoryController.js (export createCategoryController) (2nd controller)
// we will create 5 functions(controller parts) of/for categoryController...

// Now in SERVER.js (just like done for authRoute, do for categoryRoute)
--------------------
import express from "express";
import dotenv from "dotenv";
import cors from "cors";
import connectDB from "./config/db.js";
import authRoutes from "./routes/authRoute.js";

// routes
app.use("/api/v1/auth", authRoutes);
app.use("/api/v1/category", categoryRoutes)
______________________________________________________________________________

______________________________________________________________________________
then createCategoryController:

// mention async, it is callback so req, res
// ğŸ“Œkeep extensions to files names or it won't work (i.e this will not work - import categoryModel from "../models/categoryModel";)

//ğŸ“Œuse forward slash(not backslash/backward slash) in categoryRoute at beginning of url(router.post('create-category', requireSignIn, isAdmin, createCategoryController)) so create-category will become /create-category

// test with rest api client (for e.g postman), use headers, i.e Authorization(admin logged token) along with body (i.e name of category-(body->raw(json), property and value -double quoted))
// if get instead post, than 404(http://localhost:8080/api/v1/category/create-category)...

new collection will get created(category)
new documents will get inserted into that collection on each request success(create category) 
mongoDB done the task...
______________________________________________________________________________

______________________________________________________________________________
// in routes-> categoryRoute.js
//for update category
use put(neither get nor post) along url pattern '/update-category'

//now, within same file(controller-> categoryController)
below export createCategoryController, export updateCategoryControllerğŸ‰ğŸ‰

then within function export updateCategoryControllerğŸ‰ğŸ‰(LOGIC)
destructure name (as usual - from body(req.body))
but destructure id (from params (url))
//  const {name} = req.body
//   const {id} = req.paramsğŸ¨ğŸ¨
-------------------

// new:true(parameter)âš¡âš¡ is necessary to update, (it is not defined in model)- 
// category = await categoryModel.findByIdAndUpdate(id,{name, slug:slugify(name)},{new:true})

// ğŸ’€ğŸ’€as we are dynamically updating category so, in categoryRoute, inside url pattern(:id) is necessary - '/update-category/:id'

// now test using postman(restapi client)
for e.g put (http://localhost:8080/api/v1/category/update-category/686abbe5734d234b8c202274)
copy id from mongodb compass for that new collection(category), the previous document(we changed the "mobile phones" to "kids collection")

----------
// update query is working as intended
// now, get (all category) route in categoryRoutes (WE WILL NOT include any middleware, as we have to show category even if user is not logged in)

// create new function->allCategoryController in controller->categoryController
// on success, status of 200(i.e res.status(200) .send({..., category}))

// Note, as in server.js, we used category(app.use("/api/v1/category", categoryRoutes)), so can't use category keyword again in categoryRoute(router.get('/category', allCategoryController))

Now, test with postman, GET(http://localhost:8080/api/v1/category/get-category)
will showcase all categories list
______________________________________________________________________________

______________________________________________________________________________
now, singleCategoryContoller (create) and add routing just like update/create 

// modify QUERY, update-category(used :id), but single-category(will use :slug)
//while routing, use(colon slug) i.e /single-category/:slug

// test postman (get single category (it will require slug(e.g mobile phones) not id))
we tested (slug = ear-buds), i.e http://localhost:8080/api/v1/category/single-category/ear-buds

______________________________________________________________________________

______________________________________________________________________________
now deleteCategoryController (after create, update, read)
// using '/delete-category' will DELETE EVERYTHING so, use id ('/delete-category/:id')

// so finally res.status(200).send({success: true}) // deleted category
// test postman,(method=delete) e.g http://localhost:8080/api/v1/category/delete-category/686aca5c41f5df64ee78ed49(along headers(authorization)) -admin logged token

________________________________________________________________________________________

______________________________________________________________________________
ğŸƒNow same for products (just like categories),
3rd model(productModel.js) the Model-view-controller....
then routing(productRoutes.js, each route of crud along with its controller-functions),,, ... functions(for crud in productController.js)

Note: the mandatory route: (specify main route in SERVER.js), just like followings:
app.use("/api/v1/auth", authRoutes);
app.use("/api/v1/category", categoryRoutes)
----------
-------------
--------------
(So, after - CATEGORY API, NOW - PRODUCT APIğŸ””ğŸ””)
---------------
---------------
------------------
// 1.> start with productModel.js(for the very basic - database)

Within productModel.js
// the category object used in schema will have:
category: {
 type: mongoose.ObjectId,
 ref: "Category",

 // the photo object used in schema will have:
 // Note: we will not use type: Buffer (type never equals to BufferâŒ)
 photo: {
      data: Buffer,
      contentType: String,
---------------------------------------

// 2.> then specify routing/routes for different crud operations(for the very basic - connect controllers) in productRoutes.js

// within create(post) and update(put) routes, we will use Formidable(formidable())as middleware, for parsing incoming form data(the photosğŸ¦(file uploads))...

// i.e used in production, for file stream, 
// formidable(node.js package) have various versions v1, v2, v3, v4, [ express-formidable is dependent on formidable(formidable with regular updates is core, low level library() which can be used without express.jsâš¡âš¡)]

//express-formidable : The "Parser" Middleware (Parses multipart/form-data)

(as in official npm libraries docs:)

Ques. What are Express, Formidable, and this?
Ans. Express is a fast, unopinionated, minimalist web framework for Node.js.
Formidable is a Node.js module for parsing form data, including multipart/form-data file upload.
So, express-formidable is something like a bridge between them, specifically an Express middleware implementation of Formidable.

-------------------------------

// 3.> then, as specified in routes, create Controller along with functions(controller parts)(for the very basic - crud operation logic- create, update, read, delete) in productController.js

// we will create 6 functions(controller parts) of productController/-

//within productController= we will use fs(Node.js module/LIBRARY), (FOR PHOTOSğŸ¦(file upload))
// fs/file-system (core node.js module)
// i.e while create product = products.photo.data = fs.readFileSync(photo.path)
// i.e and while update product = products.photo.data = fs.readFileSync(photo.path)

// test with postman,
// add product api to server.js (i.e app.use)
//test all six functions(controller parts)

for create category function in productController;
// we taken 10 mb size,

test with postman, (use form-data in header as it shows 2 options(text/FILE), not possible in raw)
// body->form-data (not body->raw), along header(auth -admin tokenğŸ™), no params(p.)/query p.(url)
// fill up, form (along files), the fields which are in createProductController(controller parts)
// shipping set to (no required) - so, not mandatory

âš¡âš¡ğŸ’€ fields differs from files(form-data=text/file)
try{
const { name, description, price, category, quantity, shipping } = req.fields;
const { photo } = req.files;

âŒâŒpostman testing create product got error: (Internal server error-> 500)
"success": false,
    "error": {
        "errors": {
            "category": {
                "stringValue": "\"neckband\"",
                "valueType": "string",
                "kind": "ObjectId",
                "value": "neckband",
                "path": "category",
                "reason": {},
                "name": "CastError",
                "message": "Cast to ObjectId failed for value \"neckband\" (type string) at path \"category\" because of \"BSONError\""
            }
        },
        "_message": "Products validation failed",
        "name": "ValidationError",
        "message": "Products validation failed: category: Cast to ObjectId failed for value \"neckband\" (type string) at path \"category\" because of \"BSONError\""
    },
    "message": "Error in crearing product"

âœ…âœ… we have to pass category id, not name

// Now 1st ecommerce site- product created successfully (201 - created)
{
    "success": true,
    "message": "Product Created Successfully",
    "products": {
        "name": "noise airwave",
        "slug": "noise-airwave",
        "description": "best neckband from noise",
        "price": 1000,
        "category": "686c84196f0b3d14343c2e28",
        "quantity": 1,
        "photo": {
            "data": {
                "type": "Buffer",
                "data": [
                    82,
                    73,.................. it goes util 20k lines(20,000)in our system, then
.....................................            ..................
                    ........................
                     "contentType": "image/webp"
        },
        "_id": "686c84456f0b3d14343c2e2b",
        "createdAt": "2025-07-08T02:36:53.403Z",
        "updatedAt": "2025-07-08T02:36:53.403Z",
        "__v": 0
---------------------------------------------------------------------

// product will get saved to mongoDB (as the structure defined in productModel)...
// in our example:::

_id = 686c84456f0b3d14343c2e2b (objectId)

name = noise airwave (String)

slug = noise-airwave (String)

description = best neckband from noise (String)

price = 1000 (Int32)

category = 686c84196f0b3d14343c2e28 (ObjectId)

quantity = 1 (Int32)

âœ…âœ…photo = Object (Object)
---------------------------------
// the object expanded...
data = Binary.createFromBase64('UklGRixLAABXRUJQVlA4WAoAAAA4AAAA8wEA8wEASUNDUKgBAAAAAAGobGNtcwIQAABtbnRyUkdCIFhZWiAH3AABABkAAwApADlhâ€¦', 0) or full one(UklGRixLAABXRUJQVlA4WAoAAAA4AAAA8wEA8wEASUNDUKgBAAAAAAGobGNtcwIQAABtbnRyUkdCIFhZWiAH3AABABkAAwApADlh) (Binary)

contentType = image/webp (String)
----------------------------------

createdAt = 2025-07-08T02:36:53.403+00:00 (Date)

updatedAt = 2025-07-08T02:36:53.403+00:00 (Date)

__v = 0 (Int32)
---------------------------------
// test other renaming 5 functions (just like we tested category-5 functions)
// now test whole product api, just like category api

// api's testing
Now, test get product = http://localhost:8080/api/v1/product/get-product
// no headers && body required,,

"success": true,
    "counTotal": 1,
    "message": "ALlProducts ",
    "products": [
        {
            "_id": "686c84456f0b3d14343c2e2b",

// now test get single product (pass product slug(slug...(slug= url slug or just url at end)))
//get request 
http://localhost:8080/api/v1/product/get-product/noise-airwave

{
    "success": true,
    "message": "Single Product Fetched",
    "product": {
        "_id": "686c84456f0b3d14343c2e2b",
        "name": "noise airwave",
        "slug": "noise-airwave",
        "description": "best neckband from noise",
        "price": 1000,
        "category": {
            "_id": "686c84196f0b3d14343c2e28",
            .....

// 4th function, get product photo (pass product id)-objectId
// no headers and body, it showcase photo, in preview(in postman or otherwise hex code)
http://localhost:8080/api/v1/product/product-photo/686c84456f0b3d14343c2e2b

// Update product && delete product will be same (5th and 6th)âœâœ

// update product: (pass product id) - created one more product then test done...
http://localhost:8080/api/v1/product/update-product/686dc726f3d0b484fbeef53b
{
    "success": true,
    "message": "Product Updated Successfully",
    "products": {
        "photo": {
            "data": {
                "type": "Buffer",
                "data": [
                    82,
                    73, ............ 60k lines
                  },
            "contentType": "image/webp"
        },
        "_id": "686dc726f3d0b484fbeef53b",
        "name": "realme Buds Wireless 3 Neo plus",
        "slug": "realme-Buds-Wireless-3-Neo-plus",
        "description": "best neckband from realme",
        "price": 1200,
        "category": "686c84196f0b3d14343c2e28",
        "quantity": 1,
        "createdAt": "2025-07-09T01:34:30.665Z",
        "updatedAt": "2025-07-09T01:37:22.631Z",
        "__v": 0

// delete product: (pass product id), if product gets deleted, then that product(or doc) photo also gets deleted...
// in delete query, we excluded photo, due to following reason..
âŒDeletes the product, including photo= await productModel.findByIdAndDelete(req.params.pid)

âœ…Same as above, but if you want to use the deleted data afterward (e.g., send as response), you'll get it without the heavy photo = await productModel.findByIdAndDelete(req.params.pid).select("-photo")
http://localhost:8080/api/v1/product/delete-product/686c84456f0b3d14343c2e2b
without header(auth- admin-token), error: NO TOKEN PROVIDED

// WITH token : - 200(ok)
{
    "success": true,
    "message": "Product Deleted successfully"
// all 6 product functions tested(of product controller) - whole product api

(MAY BE)postman - mock server will be used, if some other api's needed for just testing purposes in frontend:
mock server = A Mock Server in Postman is a fake API server that simulates real API responses â€” without any backend code actually running.

?postman - current app -collection(with folders(& requests))'s current state in json:
// git not allowing to push secret keys (eg.
https://api.postman.com/collections/26088248-0cd11988-45ad-4626-84e5-2af949792f31?access_key=...
)
______________________________________________________________________________

______________________________________________________________________________
FRONTEND FRONTEND FRONTEND FRONTEND FRONTEND  FRONTEND FRONTEND FRONTEND FRONTEND  FRONTEND FRONTEND  FRONTEND FRONTEND FRONTEND FRONTEND  FRONTEND FRONTEND

A recap to current project state:
âœ…âœ…so in frontend src(SRC) folder, we currently have components, context, pages, styles(4 sub-folders)...

// (IN CONTEXT folder) - no sub-folders

// (IN STYLES folder) - no sub-folders

// (IN PAGES FOLDER)pages folder have pages -about/contact/pagenotfound/home/policy...
 (and 3 main pages folder i.e admin(dashboard with sub-parts), auth(login, register, forgot..), user(dashboard with sub-parts))... 

 // (IN COMPONENTS FOLDER))a component(among currently 4 sub-folders(components)- layout(for header-footer), menu, routes(private/user & adminRoute), spinner,, -------is dedicated to those dashboard pages folders i.e the menu component folder(component) with userMenu, adminMenu... (having NavLink's to different actions/routes...))
______________________________________________________________________________

______________________________________________________________________________
Now, we will display category,& perform crud (within admin panel(custom -not as good as wp admin))
----------------
so, in pages(main parent folder), - edit the createCategory.js within(admin child folder)
// as category crud should only be for admin privileges one...

useEffect, useState(hold effect changes i.e useEffect changes)... (createCategory(admin child-folder sub-page(among other adminDashboard,adminUsers,createProduct..) ))..

// and while getting categories, use notifications to let admin know if there any user in getting categories... by (import toast from "react-hot-toast";)

// then axios(to send network request), and destructure response to get data... and store using useState, then begin initial lifecycle using useEffect (and call function on initial lifecycle-for network-axios function- url pattern.../api/v1/category/get-category)

// for mapping & showcase in FRONTEND, (admin panel)
use bootstrap, table..
// bootstrap framework breakthrough...
classes:
-----------
Bootstrap provides 7 main things to developers(to implement designers' design);...
ğŸƒ The Customize section empowers developers to tailor the framework using Sass variables, global options, color palettes, and CSS variables â€” making Bootstrap flexible for any brand or theme. ğŸƒ In Layout, youâ€™ll find tools to build structured, responsive designs using containers, grids, columns, breakpoints, and utilities like z-index and CSS Grid. ğŸƒ The Content section handles core HTML elements like typography, images, and tables, styled consistently across browsers with Bootstrapâ€™s Reboot.

ğŸƒ Forms provide everything from styled inputs and selects to validation and floating labels, all customizable and accessible. ğŸƒ The Components library includes UI building blocks like modals, navbars, buttons, alerts, and carousels â€” designed to work seamlessly out of the box. ğŸƒ Helpers offer quick tweaks like clearfix, aspect ratios, and text truncation without writing extra CSS. ğŸƒ Finally, Utilities include powerful, ready-to-use classes for spacing, sizing, colors, flexbox, display, and more, making layout adjustments quick and consistent across your project.

we will use tables.. i.e part of content...
https://getbootstrap.com/docs/5.3/content/tables/ 

// paste table and convert to jsx
// show tr <table row> dynamic using map() method... ( in tr there is also th, td..)
// no columns concept in table,(i.e no tc but there is scope="col"> and scope="row">)

// 1st tr will have two cells( which is inside<thead> wrapping), (th are shown in bold)
then... tr's in <tbody> are dynamic ones...

// there is error, may be spelling mistake or something out of the box...
after checking categoryController (we got to know we are having data.category in response) or just check console logs...

---------------------
currently the table looks like: (which not working)
 <table className="table">
                <thead>
                  <tr>
                    <th scope="col">Name</th>
                    <th scope="col">Actions</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    {categories.map((c) => { âŒ
                      <>
                        <td key={c._id}>{c.name}</td>
-------------------------------------------------------
âœ… inside the map method usage, spelling/syntax mistake (using curly braces, which not returns..)
Now corrected <tbody>, with map method returning (correction done in braces syntax):
  <tbody>
                    {categories.map((c) => (
                      <>
                      <tr>
                        <td key={c._id}>{c.name}</td>
                        <td>
                          <button className="btn btn-primary">Edit</button>
                        </td>
                        </tr>
                      </>
                    ))}
  </tbody>
---------------------------------
______________________________________________________________________________

______________________________________________________________________________
add optional chaining(to prevent errors, and error notifications due to delay):
so, before:
 {categories.map((c) => (

After:
 {categories?.map((c) => (

// set table width to 75('w-75')
  <h1>Manage category</h1>
            <div className="w-75">
              <table className="table">
                <thead>

// Create Form component (new comp..) - for making buttons(i.e edit) actionable...
client-> src -> components -> Form -> CategoryForm.js

// use BootstrapğŸ˜ƒ form
// remove all input element properties(i.e aria-describedby, id..)

// add placeholder to input element along value property (which equals to prop we get)

// NOW, âœ¨LAST BUT NOT LEAST, add onSubmit event to form 
i.e  <form onSubmit={handleSubmit}>

// pass every variable(the vars, funcs,) for which we need values(i.e handleSubmit function, value, onChange property's setValue)
i.e const CategoryForm = ({handleSubmit, value, setValue}) => {

// now, as comp.. expecting values from the page, so:
NOTEâš¡ğŸ’€ğŸ’€: change js-> jsx(to make EMMET ABBREVIATION WORK..) FOR making div's by .CLASS_NAME

Note: keep code readable, by placing code in right place(programming standards)..
i.e inside functional comp.. createCategory(which is hypothetically page(as we are creating react app))
// at least (refs are exception), 7 should be placed (grouping and ordering logically)
// there are certain React's rules of hooks like:
âŒ Not Recommended:
Placing new useState below function declarations or inside conditionals can break Reactâ€™s Rules of Hooks.

// correct ones âœ…
 // 0. Imports (libraries, components, styles)
 // 1. Constants (API endpoints, helpers)
 // 2. State hooks (i.e any no. of useState hooks should always be placed upside of a useEffect)
 // 3. Refs (if any, using useRef for DOM or mutable values)
 // 4. useEffect hooks
 // 5. Event handlers or functions
 // 6. Return JSX

FOR MORE SECTIONS::âœ…
------------------
// 0. Imports (libraries, components, styles)
// 1. Constants (API endpoints, environment vars, derived constants)
// 2. State hooks (useState for managing component state)
// 3. Refs (if any, using useRef for DOM or mutable values)
// 4. Derived or memoized values (useMemo/useCallback to optimize calculations or handlers)
// 5. Contexts (useContext for accessing global/auth/theme/etc. context)
// 6. useEffect hooks (for side effects like API calls, subscriptions)
// 7. Event handlers or functions (onClick, onChange, submit handlers, API calls)
// 8. Conditional render helpers (optional functions that return JSX snippets)
// 9. Return JSX (final render output)

// For more sections (along ts(TYPESCRIPT))... & every elementâœ…âœ…
// 0. Imports (libraries, components, styles)
// 1. TypeScript interfaces or types (for props, state models, component structure)
// 2. Constants (API endpoints, environment vars, derived constants)
// 3. State hooks (useState for managing component state)
// 4. Refs (if any, using useRef for DOM or mutable values)
// 5. Derived or memoized values (useMemo/useCallback to optimize calculations or handlers)
// 6. Contexts (useContext for accessing global/auth/theme/etc. context)
// 7. Reducers (useReducer if using more complex state management)
// 8. useEffect hooks (for side effects like API calls, subscriptions)
// 9. Custom hooks (if you've abstracted reusable logic into separate hooks)
// 10. Event handlers or functions (onClick, onChange, submit handlers, API calls)
// 11. Conditional render helpers (optional functions that return JSX snippets)
// 12. Cleanup logic (within useEffect's return function for timers, subscriptions, sockets, etc.)
// 13. Return JSX (final render output)

ğŸ“˜ğŸ“˜  What React Docs Emphasize/Focuses, is whatever added later, should be placed later(added later, place later) (like hooks strictly follows react's rule of hooks).. below existing ones, (be it any element declaration in any section), then prettier format 

i.e ğŸ§­ â€œAdded later, placed laterâ€ â€” within the correct section â€” is the practical standard.
(states, effects, functions) at bottom of their respective sections...

But expections- â—â€œadded later â†’ placed laterâ€ rule does not strictly apply to imports (IMPORTS)
// imports have another rule...(another civilization)...
1. React and core libraries (e.g., react, react-dom)
2. Third-party packages (e.g., axios, lodash)
3. Absolute imports (e.g., from '@/components/...')
4. Relative imports (e.g., './Component', '../utils')
5. Styles (e.g., './styles.css')

// now coming to category form component && category form page...
pass prop values from page..
i.e BEFORE <CategoryForm /> -> AFTER <CategoryForm handleSubmit={handleSubmit} value={name} setValue={setName} />

AND, also call get all category again, after categoryForm submit... for showcasing just added..
handleSubmit function()...
 if (data?.success) {
        toast.success(`${name} is created`);
        getAllCategory()

// âš¡âš¡âš¡For edit functionality(in Manage category, of admin panel), we will use ANT-DESIGN..

npm install antd and npm install antd --save (SAME)
â“â“
Before npm 5: npm install antd would only install the package, while npm install antd --save would install it and add it to package.json.

Since npm 5 (and current versions): npm install antd automatically includes the --save behavior. So, npm install antd --save is redundant because --save is the default.
----------------------
//now, ant-design re-usable components...
import ant design,, then
// ant-design 5 (currently it's v.5), navigate to feedback -> Modal

Modal -  visible={ } deprecated, use open={ } instead, as of v.5 (antd)..
if one function to call (using onClick event) =  onClick={() => setVisible(true)}
if two or more func.. to call =   onClick={()=>{setVisible(true); setUpdatedName(c.name)}}

// now in updateForm function (invocable) will have:/cat/update-cat/:id(dynamically)...
await axios.put(
        `${API}/api/v1/category/update-category/${selected._id}`,{name:updatedName})

// on successful category updation, do:
notify user, reset values, refresh page content (to show updated categories)...
 if (data.success) {
        toast.success(data.message);
        setSelected(null)
        setUpdatedName("")
        setVisible(false)
        getAllCategory()

// Now delete category... 
now modify the delete button inside map method
<button className="btn btn-danger ms-2" onClick={()=>{handleDelete(c._id)}}>
                            Delete
                          </button>

// on successful delete, 
const handleDelete = async (cId) => {
    try {
onst { data } = await axios.delete(
        `${API}/api/v1/category/delete-category/${cId}`,
        { name: updatedName }
      );
if (data.success) {
        // toast.success(data.message);
        toast.success('Category deleted successfully');
        getAllCategory();
// inform user, and refresh the latest categories

// Now, the crud operations (read, create, update, delete) done for managecategory(in admin panel)

// so, category FRONTEND (admin's FRONTEND i.e manage - category) done...

// Now product api showcase in Manage product(admin panel)..
create separate page, (because categories can be few tens, but product will be hundreds..)

// now, product FRONTEND (admin's FRONTEND i.e manage - product)..

// â­ğŸŒŸâœ¨ firstly, present the products for management, crud-management, - useState, useEffect
// we need to get everything from product model
// so createProduct(the manage product interface) will have:
const [categories, setCategories] = useState([])
const [photo, setPhoto] = useState("").. same for name/desc../price/quantity/shipping

// copy getAllCategory function from createCategory( the manage category interface) 

// copy useEffect hook of createCategory( for invoking that copied function)
// copy imports to be used..

NOTE: something getting response takes time, so, ALWAYS ENSURE OPTIONAL CHAINING e.g data?.key

// now, in createProduct(the product crud interface(manage)).. add dropdown...
import { Select } from "antd";
const {Option} = Select;

// add Select (from antd) and add click event along the prop(value) provided by antd(not react)

// now, finally add <Option> within map method inside Select, with key and value

// now product interface(admin panel) will show dropdown having categories, and option to search for various categories and select any of them..âœ…
// current state of product management is(only first state(storage) is used i.e categories..)

// now difficult part to make category (DIRECTLY PROPORTIONAL) to products, (as joining their logic have conditioning..)..

// add upload photo functionality.. (div container element...)
            <div className="mb-3">
                <label className="btn btn-outline-secondary col-md-12">
                  {photo ? photo.name : "Upload photo"}
                  <input
                    type="file"
                    name="photo"
                    accept="image/*"
                    onChange={(e) => setPhoto(e.target.files[0])}
                    hidden
                  />
                </label>
              </div>

// Now, to show selected image( BrowserğŸ˜ƒ also have some properties)

// this will not work:
<div className="mb-3">
                {photo && (
                  <div className="text-center">
                    <img src={photo} alt="" />
                  </div>
                )}
              </div>

// to make image preview work, (A NORMAL BrowserğŸ˜ƒ PROPERTY USE-CASE, package can be used if needed)
             <div className="mb-3">
                {photo && (
                  <div className="text-center">
                    <img
                      src={URL.createObjectURL(photo)}
                      alt="product_photo"
                      height={"200px"}
                      className="img img-responsive"
                    />
                  </div>
                )}
              </div>

// now, input fields for product(after image)
//add input
//along onChange(bind onChange values with states (e.target.value))

// use inputs, textarea, select(along with options) and then normal button with onClick event

// new function handling the inputs sent by button, 
// use form data while destructuring (i.e const {data}= axios.post) or
 INSTEAD WRAP [INPUTS, TEXTAREA(DESCRIPTION),SELECT] TAGS WITH [FORM TAG] AND TRIGGER SUBMSSION ON {FORM - onSubmit}

// so, if all the product's inputs (photo, name, desc, shipping...) with <FORM> tag and use its onSubmit.. (YOU NOT HAVE TO GO THROUGH MANUAL FORM-DATA BEFORE  destructuring i.e)
 const productData = new FormData()
      productData.append('name', name)
      productData.append('description', description)
      productData.append('price', price)
      productData.append('quantity', quantity)
      productData.append('photo', photo)
      productData.append('category', category)
       productData.append('shipping', shipping) {/*necessary*/}
      const { data } = axios.post

// using optional chaining for fallback during delay(ie. data?.success) or Use data && data.success
navigation route not created yet, 
just for checking(routing on success or not),
 i.e if(data?.sucess) navigate('dashboard/admin/products')

// NOTE - FACT: add semicolon(;) in b/w code and comments (for example - the following statement) 
  productData.append('shipping', shipping); {/*necessary*/}

// Product create done (also routing, re-directing)âœ…

ADD NEW PAGE(comp) to admin -Products.js, besides (AdminDashboard,CreateCategory,CreateProduct,AdminUsers)
// NOTE: VS CODE shortcut -> while on opening tag (PRESS f2)ğŸ”¥ğŸ”¥ to change both opening + closing tag (same time)..

// Now add this,(i.e PAGE(or comp)) to App.js 
  <Route path="/dashboard" element={<AdminRoute />}>
          <Route path="admin" element={<AdminDashboard />} />
          <Route path="admin/create-category" element={<CreateCategory />} />
          <Route path="admin/create-product" element={<CreateProduct />} />/
           <Route path="admin/users" element={<AdminUsers />} />/
           <Route path="admin/prooducts" element={<Products />} />/
        </Route>

// Now add this to Admin - Menu...(along with navLink like others one)

// as we have getAllProduct already in ProductController, so now represent products - frontend(admin panel)

now withing Products.js (admin panel), add destructure the data from network request(i.e {data} = await axios.get(``))

after that,
// USE LIFECYCLE METHOD, i.e useEffect(for invoking function to get product(s))

// NOTEâš¡ğŸ’€ğŸ’€: check in advance (if getting products or not) in FIREFOX -> dev tools -> network->(click on request)->304(get)->response (structure like json, products array...)

// copy CARD from bootstrap... (components-> card)
now map products in the card...

// not getting photo, hit another api (of Product API), to get photo(s)

NOW, FOR EVERY SINGLE PRODUCT, use link (from react router dom)

// as in firefox(dev tools), network tab showcasing (slug) in response in get request
so, each product LINK to that slug,,
// re-design later, but also prevent errors like (same slug)

// not add ${API}(the backend url)[LINK to={}] (as navigation happening in frontent) i.e not a net request..
// but add ${API}(the backend url) for network request, i.e to get product image [IMG src={}] (NO NEED AXIOS HEREğŸ”¥ğŸ”¥..)
 <div className="d-flex">
             {products?.map((p) => (
                <Link key={p?._id} to={`/dashboard/admin/product/${p?.slug}` } className="product-link">
                   <div className="card m-2" style={{ width: "18rem" }} >
              <img src={`${API}/api/v1/product/product-photo/${p?._id}`} className="card-img-top" alt={p?.name} />
              <div className="card-body">
                <h5 className="card-title">{p?.name}</h5>

// Now just like Products.js, 
ADD UpdateProduct.js ğŸğŸ to admin..

COPY createProduct input fields (along whole layout) to updateProduct...

COPY createProduct functions to updateProduct...

COPY createProduct imports to updateProduct...

// before editing updateProduct.js (add it to App.js) hand in hand/ side by side..
  <Route path="/dashboard" element={<AdminRoute />}>
          <Route path="admin" element={<AdminDashboard />} />
          <Route path="admin/create-category" element={<CreateCategory />} />
          <Route path="admin/create-product" element={<CreateProduct />} />/
          <Route path="admin/product/:slug" element={<UpdateProduct />} />/ // <-HEREğŸ”¥ğŸ”¥ also, add slug
          <Route path="admin/users" element={<AdminUsers />} />/
          <Route path="admin/products" element={<Products />} />/
        </Route>
// debug and show the errors like toast (for e.g if photo>1 mb) on catch( toast.error(err?.response?.data?.error))

// not confirm of the docs, but useEffect should above all functions.. (useEffect is good to below states(storages))

// now add useParams (to get url)
so, params = useParams()

// populate all fields with data(of the product) which we are editing... (from the destructured data)
// add second(2nd) useEffect, updateProduct, (first for getting cats.., second for getting data of prod..(and populate))

// category, and shipping having issues(in getting populated by data in database)...
FIXâœ… add value property to form fields element (.ie value={category}, value={shipping}) [ğŸ“Œstates are already populated..]

// NOTEâš¡ğŸ’€ğŸ’€ 
use trim() method, before sending form fields data to BACKEND(mongo in our case).. Avoid validation issues (e.g., backend rejecting a string that's technically not empty but only has spaces). (and remove whitespaces)

// now for photo, 
// paste src of Products.js when showcasing {products? (): (HEREğŸ”¥ğŸ”¥)}

// now the button, handleCreate will become handleUpdate... so the api,,
// and change METHOD TYPE to put...

// getting error while product updation, so change the form(form = formData()'s setCategory(data.product.category._idğŸ”¥ğŸ”¥))
// while updating that state, change the input field's value too, ie. (from category.name to category)

[object Object]
ğŸ”¥ğŸ”¥NOTEğŸ”¥ğŸ”¥ 
onChange={(value)=>setCategory(value)}
 ---------- same as --------------------
onChange={setCategory}

âš¡ğŸ’€âš¡âš¡â” onChange={(value) => setCategory(value)} is explicit and useful if you plan to modify it later,,
or if value needs some changes .ie(onChange={(value) => setCategory(value.trim())}),, 
or if multiple param needed (onChange={(value, option) => setCategory(value)})

// now add handleDelete to same updateProduct (later we redesign)...

so, just hit the endpoint ...  
const {data} = axios.delete(`${API}/api/v1/product/delete-product/${id}`)

but add deletion confirmation prompt (i.e window.prompt)

let answer = window.prompt('Do you want to delete product?') (BUT Recommended = WINDOW.CONFIRM(USER NOT HAVE TO CODE))
        if(!answer) return;
        const {data} = axios.delete(`${API}/api/v1/product/delete-product/${id}`)

// ğŸ“duplicate slug issue is still with us, (causing to open product which get created first in database);

// before that slug issue, and users(in admin panel) - begin with HomePage

.. Frontend// FRONTEND ..
ğŸ˜ğŸ˜ğŸ˜ğŸ˜ğŸ˜
// FRONTEND FRONTEND FRONTEND FRONTEND  FRONTEND FRONTEND FRONTEND FRONTEND  FRONTEND FRONTEND FRONTEND FRONTEND  FRONTEND FRONTEND FRONTEND FRONTEND  FRONTEND FRONTEND FRONTEND FRONTEND  FRONTEND FRONTEND FRONTEND FRONTEND  FRONTEND FRONTEND 

show products (along filters for sorting and others)... HomePage.js (-- jsx code)
<Layout>
//STEP 1 =  .row mt-3 (ROW)
//STEP 2 = (various columns, for now) .col-md-3 && .col-md-9 (COLUMNS)
//STEP 3 = useState-products/categories, lifecycle-method(useEffect)

//STEP 4 = HAVE .col-md-3(with h4, Filter by category) and .col-md-9(with h1, all Products)
//STEP 5(last) = .d-flex flex-wrap(within .col-md-9, all products)
----------FIRST FUNCTIONALITYğŸ¨ğŸ¨, THEN RE-DESIGNğŸŒˆğŸŒˆ
........... present the products to all.. users(normal users), admin(advanced users)

// COPY products(of admin) to homepage, to products showcase, 
// add (add to cart /more details) button -> as of now, copy styling... BootstrapğŸ˜ƒ

// now display categories
// user can select multiple categoryğŸ“ŒğŸ“Œ
// as of now, styling... Ant-Design(antd)..

// there will also other filters like price(styline will be done later on)...

// in Homepage, on basis of checkbox, we will get categories(just like in ecommerce apps), & no toast notifications should be get implemented, for categories error...

{ /* ------- category filter --------- */ }
 {categories?.map((c) => (
              <Checkbox
                key={c._id}
                onChange={(e) => handleCatFilter(e.target.checked, c._id)}
              >
                {c.name}

// for multiple categories select/check(have state[ ]) i.e [checked, setChecked] = useState([ ])

// on checkbox(s) (of categories), -onChange -invoked function will take 2 paramsğŸ¨ğŸ¨ (state-what checked[] and those cat id's..) i.e val,id

// e.g handleCatFilter, (val,id)...

USE SPREAD OPERATOR(...) TO STORE ALL CATEGORIES ..i.e 
 let all =  [...checked ]
-----------------------------
example of handleCatFilter...
----------------------------
 let all =  [...checked] ;
    if (value) {
      all.push(id);
    } else {
      all = all.filter((c) => c !== id);
    }
    setChecked(all);

not test on the go in frontend, using JSON.stringify(checked, null, 4), 
// after ensuring, filter operation is performing successfully, now

// Now, NEWğŸ“Œ component (PRICE'S BASED FILTER)

currently, we created new directory inside components i.e (Filters)
inside which,, we created Prices.jsâš¡âš¡

EXPORT IT AS = ARRAY OF OBJECT'SğŸ˜…

create various prices filters.... ğŸ§ 
Example =

export const Prices = [
    {
        _id:0,
        name:'$0 to 19',
        array:[0,19]
    },
    {
        _id:1,
        name:'$20 to 39',
        array:[20,39]
    },
......
At the end of the ARRAY OF OBJECT's
we can use...
   {
        _id:5,
        name:'$100 or more',
        array:[100,9999]
    },
______________________________________________________________________________

______________________________________________________________________________
Now a utility like file is created (Src->Components->Filters->Prices.js) with help of which we will create filter

We have done already,,i.e Filter by category

Now, add newly created,,i.e Filter by price
// so in homepage, we will show prices ------------by map method on the utility/component
i.e export array of objects, Prices.jsâš¡âš¡ 
prices =[{},{}]

use radio button from ant-design..
just like [checked, setChecked] have, [radio, setRadio] to have same categories like state (same to same) products ([])

example of the products filter for homepage being applied...
{ /* ------- price filter -------- */ }
 <Radio.Group onChange={(e)=>setRadio(e.target.value)}>
              {Prices.map((p) => (
                <div key={p._id}>
                <Radio value={p.array}>{p.name}</Radio>

______________________________________________________________________________

______________________________________________________________________________
ğŸ˜ğŸ˜ğŸ˜ğŸ˜ğŸ˜ğŸ˜ğŸ˜ğŸ˜ğŸ˜
// BACKEND BACKEND  BACKEND BACKEND BACKEND BACKEND BACKEND BACKEND BACKEND BACKEND BACKEND BACKEND BACKEND BACKEND BACKEND BACKEND BACKEND BACKEND BACKEND BACKEND BACKEND BACKEND  BACKEND BACKEND BACKEND

Efficient BACKEND, 
if we create filter functionality to each product in frontend, then it will get complex, so we will add it in the backend, for the efficiency

.....
Now let's use the (category filter) and (price filter)... in the ecommerce application/-

filter operation...
new function in backend,

new request for Filters(get)
----------------------------------
so, in backendğŸ”¥ğŸ”¥
route, controller(filters)

within productRoutes.js
router.get('/product-filters', productFiltersController)

within productController.js
new export function productFiltersController)

 try {
  ------------------------
  } catch (error) {
    console.log(error);
    res.status(400).send({
      success:false,
      message:'Error while filtering products',
  {/* pass error as it is */}
      error
    })
... 

logic - get checkBox and radioButton...
// now two ways..

write direct query and pass it to function

or have a variable storing the query (like usually seen inside functions..)
----
so as there are multiple queries (work on checkBox, work on radioButton)
// maybe user want both category filter &  price filter (or just single)
    // so if multiple, then multiple (else single)
    // checked initial value is 0 (in frontend), and also value of produt radioButton (in fronend) -- so fulfill

    // maybe user want both category filter &  price filter (or just single)
    // so if multiple, then multiple (else single)
    
-----
try{
  ------------

 const [checked, radio] = req.body
    let args = {}
    // maybe user want both category filter &  price filter (or just single)
    // so if multiple, then multiple (else single)
    // checked initial value is 0 (in frontend), and also value of produt radioButton (in fronend) -- so fulfill
    if(checked.length > 0) args.category = checked
    // as array have two values,so use mongo queries that are <,>(so first get index, then filter),i.eLTE(less than equal to)
    // lte and gte will get 0th position and 1st position i.e ARRAY[0,1]
    if(radio.length) args.price = {$gte: radio[0], $lte:radio[1]}
    const filteredProducts = await productModel.find(args)
    res.status(200).send({
      success:true,
      filteredProducts
    })

  -----------
}

âœ…âœ…âœ…NOTE: as we are passing values, so it will be post request...
post = passing values..

so values possible passing = POST(frontend/backendğŸ”¥ğŸ”¥)
// pass checked, radio..
// checked for categories, radio for price...
âœ…So, if frontend sending params... whatever any data like a post-master sending letters than post-method...
______________________________________________________________________________

______________________________________________________________________________
// getAllCategory 1st lifecycle method is just for getting categories...

// modify 2nd lifecycle method ( of getAllProducts )
 useEffect(() => {
    if(!checked.length || !radio.length) getAllProducts();
  }, []);

// add+ one more lifecycle method(3rd)
  // Lifecycle method , getAllProducts is running only in initial (and only if no filter(cat,price) being used)
  useEffect(() => {
    if(checked.length || radio.length) getFilteredProducts()
  }, [checked, radio]);

ğŸ”¥ğŸ”¥NOTEğŸ”¥ğŸ”¥ we are having conditional at the very beginning in map method(i.e anything?.map) then within that block we need very less conditionals as we have something in that anything(is assured)

// corrected an issue;
ğŸ’¥ Problem:
Your frontend sends an object: { checked, radio }

But your backend is trying to destructure it as an array: [checked, radio].

âœ… Solution:(backend)
const [checked, radio] = req.body; ğŸ‘‰ To: const { checked, radio } = req.body;
//Now checked and radio will be properly pulled from the object sent by the frontend.

ğŸ” type safety, that's why type-script is preferred///
ğŸ” graphql api's are good for ecommerce like sites, as sends only data needed specifically (eg. name - firstname only)

// postman /product/product-filters testing done
_______________________________________________________________________________

______________________________________________________________________________
filtered products not proper in ui///

DEBUG: ,, log what you are sending...
Eg. if only 1 category selected without price filter
Sending filters to backend: 
Object
checked : ['686acf148df25869cbd8c891']
radio : []
[[Prototype]] : Object
-------

âœ… Problem
The backend is returning:
___________________________
res.status(200).send({
  success: true,
  filteredProducts,
});

The frontend is expecting:
____________________________
setProducts(data?.products); // i.e. data.products

âš ï¸ Mismatch in key name:
__________________________
Backend sends â†’ filteredProducts

Frontend expects â†’ products
____________________________

Also, logging also providing undefined...(as the key in not in the response)
Correction made..\\

O...AI logo
Oops, an error occurred!
Route Error (500 ): {
  "isTrusted": true
}

O...AI logo
Oops, an error occurred!
Operation timed out

O...AI logo
Oops, an error occurred!
Route Error (409 ): {
  "error": {
    "message": "Invalid client. Please start over.",
    "type": "invalid_request_error",
    "param": null,
    "code": "invalid_state"
  }
}

// so backendğŸ”¥ğŸ”¥ will be updated as needed...
user will send requests typically involving sending JSON payloads containing the user's input.. or whatever variables we want to pass in payload (and as discussed before, whenever there is a payload/passing then POST method)

// adding price range(RESET functionality)
We need to store "all" as the selected value when resetting, 
instead of resetting to []

Then, inside the backend call logic, treat "all" as no price filter.
// issue: After once reset price radio move to some price range, then after selecting again the reset price radio not showing blue dot
Ensure efficiency...
âœ… 1. Update radio state initialization
âœ… 2. Update Radio.Group to use string IDs
âœ… 3. Update getFilteredProducts to convert ID to array
âœ… 4. Update useEffect dependency logic for products
ux improvement(reset price range radio button done..)
______________________________________________________________________________

______________________________________________________________________________
now ui improvement, (for products card, mix up bootstrap with custom css)
++ index.css
__________________________
.product-card {
  width: 18rem;
  height: 32rem;
}

.product-img {
  height: 200px;
  object-fit: cover;
}
___________________________
   {products?.map((p) => (
              <div className="card m-2 product-card" style={{ width: "18rem" }}>
                <img
                  src={`${API}/api/v1/product/product-photo/${p?._id}`}
                  className="card-img-top product-img"

// products not get covered fix, not height (non-properly)
/lets chef codechef.. for more css -coursera
/ai->LLMs - text, image, audio... (SUPERVISEDğŸ”¥ learning-labeling things, Neither Re-inforcement Nor Un-supervised= gen aiâœ…)

begin the add to cart, more details(and backend re-design, that duplicate slug issue)..

corrected duplicate -slug...
1st createProductController
new helper function..

2nd updateProductController..
When you update a product, and you change its name, the backend will generate a new slug from that name.
If another product already has that slug, MongoDB will throw a duplicate key error (E11000 duplicate key error) â€” because the slug field is marked unique.
i.e. Name changed & new slug is unique -> Proceed âœ…
&& if Name changed && (NEW SLUG EXISTS) -> generateUniqueSlug() appends -1, -2, etc.
_______________________________________________________________________________

______________________________________________________________________________
// Stories
Be inspired ...
// now the products are bit ok in frontend homepage, and also ok while during admin panel product creation, listings and updation,,

//  NOW PAGINATION, WE CAN'T SHOW EVERY PROJECT IN 1 GO (DUE TO future API LOAD) && a tiny reset button (below filtersğŸ™)

for reset button, ğŸ™Make the filters fully "controlled" inputs (price range done already), make the categories too..

// FULLY CONTROLLED INPUTS means:
Explicitly provide the checked stateâœ… to each checkbox and the valueâœ… to each radio group

 {categories?.map((c) => (
    <Checkbox
      key={c._id}
      onChange={(e) => handleCatFilter(e.target.checked, c._id)}
      
    >

// removed default radio button (i.e all prices for now)...
( removed the default (all prices radio button) which looks odd)

// ++ added reset filters button 

// moved prices.js(a constant) from components to new directory(i.e data)...

// pagination (show limited products)...(client side or server side both can be done(we going for backend side))

// for total products count = name the endpoint whatever(we chosen product-count, then assign a controller logic)

productRoutes -> '/product-count',productController
productController -> productCountController (send resonse i.e await productModel.find({}).estimatedDocumentCount())

// for products per page = again name the endpoint whatever(we chosen product-list, then assign a controller logic)
NoteğŸ“ŒğŸ“Œ: use mongoose queries (to perform operations) with responsibility..

productRoutes -> '/product-list/:page',productListController
 const page = req.params.page ? req.params.page : 1;
ğŸ§ -> (send response i.e productModel.find({}).select('-photo').skip((page-1) * perPage).limit(perPage).sort({createdAt:-1}))

// THE-CORE-LOGIC-IN-OUR-PAGINATION
.skip((page - 1) * perPage).limit(perPage)

// This entire calculation (page - 1) * perPage 
gives you the offset (or skip amount) â€“ the number of items to bypass from the beginning 
of your dataset before you start selecting the items for the current page.

âœ…âœ…page - 1: This adjusts the page number 
(which is typically 1-indexed for users, meaning "Page 1", "Page 2", etc.) 
to a 0-indexed or 1-indexed starting point 

âœ…If page is 1, (1 - 1) gives 0. This means you want to skip 0 items from the beginning.
âœ…If page is 2, (2 - 1) gives 1. This means you want to skip 1 full page of items.

ğŸ”¥ğŸ”¥* perPage: This multiplies the adjusted page number by 
the number of items you want on each page.

ğŸ”¥0 * perPage: If you're on the first page, you skip 0 items.
ğŸ”¥1 * perPage: If you're on the second page, you skip perPage number of items (i.e., you skip all items from the first page).

((( in js- normal javascript, we writes something like following)))
const allProducts = [
  { id: 1, name: "Laptop" },
  { id: 2, name: "Mouse" },
  { id: 3, name: "Keyboard" },
  { id: 4, name: "Monitor" },
  { id: 5, name: "Webcam" },
  { id: 6, name: "Headphones" },
  { id: 7, name: "Microphone" },
];
const totalItems = allProducts.length; //----------> 7
const itemsPerPage = 3;   // ------------------> decide page size (we set anything like for eg. 3)

// Calculate total pages (for UI and navigation) i.e if we have page size =3, then how many pages?? pages(or total pages)=%ğŸŒˆ
const totalPages = Math.Estimate(totalItems / itemsPerPage)âœ…; // HERE roundup = Estimate(for Uneven Division (with a remainder))

.Estimate = ceil/round-up (sets MINIMUM pages for all data && ensures that even if there's only one item left that doesn't fill a whole page, an additional page is created for it,)
______________________________________________________________________________

______________________________________________________________________________
// pagination logic in frontend..
create new state in homepage(where we are working on the products showcase(along all prices, categories...))

// having functions and lifecycle methods for that..
print and check (for debugging, hand to hand)...
example: 
 <div>
            {total}
 </div>
 // the total showcase (Total Created Products Count)

// Now replacing (<div>{total}</div>) with pagination...
// WE WILL KEEP ADDING PRODUCTS AFTER(EVERY 6 PRODUCTS(I.E PAGINATE)), 6 IS SET ON backendğŸ”¥ğŸ”¥

// so, for {total} replacement(showing total created products count)
 {products && products.length < total && (
              <button className="btn btn-warning"
                onClick={(e)=>{
                e.preventDefault();
                setPage(page +1); // âœ… page INCREMENT 
                }}
              >
                {loading? "Loading..." : "Load more"}
              </button>
  ) }

// NOW CHANGE PRE-EXISTING FUNCTION(i.e // GET ALL PRODUCTS), and set states inside it, named setLoading (T/F)

// developers - disaster (un-utilize/un-learn = await axios.get(`${API}/api/v1/product/get-product`);) - beneficial as now the backend not query all products using that api, so backend resources(eg CPU) get saved/not spike...

// now GET ALL PRODUCT will hit another api endpoint, i.e axios.get(`${API}/api/v1/product/product-list/${page}`);

WHATSOEVER
// now the load more button show (only if total created products(i.e total ) > 6)

// work on (LOAD MORE) functionality...

// we can also add search based filters(so, for execute in existing queries.. KEYWORD state needed)

ğŸ”¥ğŸ”¥context api - keyword(for search functionality)ğŸ”¥ğŸ”¥
//before that keyword stateâœ…, have route in backend for searchig procedure execution

// for search product = name the endpoint whatever(we chosen search-product, then assign a controller logic)

productRoutes -> '/search-product',searchProductController
productController -> searchProductController (send resonse i.e )

so, search product (will be based on (kEYWORD)), just as (/product-list/:page(product list is now based on page))
ğŸ”´ // now a common issue encountered,, 

a common issue with infinite scroll / "Load More" behavior combined with filters:

/**
 * âœ… Final Setup: Filtering + Pagination Working as Expected
 * This page supports seamless filtering and paginated loading of products.
 *
 * -----------------------------
 * ğŸ”„ HOW IT WORKS:
 *
 * 1. On Initial Load:
 *    - Fetches the first page of all products from backend (`page = 1`).
 *    - Also fetches total product count to determine pagination bounds.
 *    - All categories are loaded for filter UI.
 *
 * 2. Filtering Logic:
 *    - Filters use checkboxes (category) and radio buttons (price range).
 *    - Filters trigger a re-fetch of filtered products, respecting `page`.
 *    - If page = 1 â†’ replaces products, else â†’ appendsâ­ next filtered page.//----------> roughly saying filtering appends
 *    - Filtered count is tracked using `filteredTotal`.
 *
 * 3. Load More (Pagination):
 *    - Button click increments `page`.
 *    - Based on current filter state:
 *        â€¢ If filters active â†’ fetch next page of filtered results.
 *        â€¢ If no filters â†’ fetch next unfiltered page.
 *    - Fetched products are appendedâ­ to existing list.//----------> roughly saying pagination appends
 *
 * 4. Reset Filters:
 *    - Clears all filters (`checked`, `radio`).
 *    - Resets page to 1 and product list to default.
 *    - Also resets `filteredTotal`.
 *    - Re-fetches product count and page 1 unfiltered products.
 *
 * -----------------------------
 * âœ… TECHNICAL NOTES:
 *
 * - All fetching logic uses the `page` state.
 * - `useEffect` listens to changes in `page`, `checked`, and `radio`.
 * - `filteredTotal` is used to cap pagination when filters are active.
 * - `total` is used when there are no filters.
 *
 * -----------------------------
 * ğŸ”§ Backend Routes Hit:
 *
 * - `GET  /product-list/:page`             â†’ paginated product list
 * - `POST /product-filters`                â†’ paginated, filtered list
 * - `GET  /product-count`                  â†’ total number of products
 * - `GET  /category/get-category`          â†’ category list for UI
 * - `GET  /product-photo/:id`              â†’ product image
 *
 * -----------------------------
 * âœ… Solved Issues:
 *
 * âœ… Pagination was previously replacing products instead of appending.
 *    â†’ Now appends new pages correctly using page state.
 *
 * âœ… Filters used to fetch all products at once.
 *    â†’ Now sends pagination details along with filters.
 *
 * âœ… Reset filters didnâ€™t fetch fresh unfiltered data.
 *    â†’ Now resets `page`, clears filter states, and re-fetches.
 *
 * âœ… Filters didnâ€™t reactively change data if already multiple pages loaded.
 *    â†’ Controlled via unified useEffect on `[page, checked, radio]`.
 *
 */


// in terms of efficiency, 
if, else if, else if (is performant)
as compared to if, if, if

The backendğŸ”¥ğŸ”¥ and frontend working properly; checked official FLIPKART--

// reduce backend cluttering, by having specificity(in req);

// we had modified the request to send the correct queries to perform from frontend i.e (price:1/-1, createdAt:-1)

// while using ref (useRef()) for sorting, we changed/updated the sorting parameters to have id(without spaces), as databases not tackles the spaces (white spaces) correctly, kind of cluttering increases, in ctrl(controller)'s in backendğŸ”¥
i.e.
const sortRef = useRef(null);

  const sortType = [
    {
       _id: "pricelowtohigh",
      name: "Price -- Low to High",
      type: "price low to high",
    },
..........
-------------------------------------------------
----------------------------------------------------------
--------------------------------------------------------------------------
Now i recognized that the issues aren't due to "bad code" â€” theyâ€™re mostly about how pagination and filters are conceptualized and expected to behave.
---------------------------------------------------------------------------
--------------------------------------------------------
------------------------------------------------
  â“â“ What should be the behavior?â“â“

  ğŸ”µ Default Flow (No Filters)
  1> Load More should incrementally load more products based on the current page (pagination).
  2> Each click should append the next pageâ€™s products.
  3> If there are no more products, it should disable/hide the button.

  ğŸŸ¢ Filtered Flow (With Filters Active)
  1> The initial filter action (checked or radio) should:
  2> Reset the product list.
  3> Set page = 1.
  4> Fetch filtered products (for page 1).

  ğŸ”´ Load More should:
  1> Fetch the next page of filtered results.
  2> Append those results to the product list.
  3> Stop when all filtered products are loaded.

  âœ…ğŸ§  Reset Filters Should:
  1> Reset checked, radio, and page.
  2> Re-fetch page 1 of unfiltered products.
  3> Replace product list with fresh, default products.
______________________________________________________________________________

______________________________________________________________________________
Now after that (filtering + load more) behaviour...
ğŸ” Filter = â€œWhich products?â€
ğŸ”ƒ Sort = â€œIn what order?â€

ğŸ’¡ query should be something like///////////////////////////////////////////////////////////////////////////
Product.find({
  category: "Mobile",
  price: { $gte: 10000, $lte: 20000 },
}).sort({ price: 1 });

//////////////////////////////////////////
find({ ... }) = filter
.sort({ ... }) = sort
âœâœâœâœâœâœâœâœ
then the extra logic eg. pagination ...
   .skip((page - 1) * perPage)
   .limit(perPage)
  ............................
//////////////////////////////////////////////
ğŸ”¹ First: What Should Be the Behavior? (sorting)

âœ… When no filters are applied:
First page loads products (e.g., 9 items).
Clicking "Load More":
Loads next page from backend (e.g., page 2 â†’ 9 more items).
Appends to existing product list.
Products stay sorted according to selected "Sort By" option.

âœ… When filters are applied (category/price):
Page is reset to 1.
First page of filtered products is fetched (sorted accordingly).
Clicking "Load More":
Loads next page of filtered products (e.g., page 2 of the filtered subset).
Appends them to current filtered product list.
Stops loading when filtered products run out.

âœ… When filters are cleared:
Page resets to 1.
Original products list starts loading again from first page.
Any sort preference remains (or resets if specified).
_______________________________________________________________________________

______________________________________________________________________________
    // so all the parts working that should work for users(like load more is working perfectly) as in other well researched sites like flipkart, amazon, (we are just not got the logic of what ux should be there, so we sync with real world)

    //so, now we can work on search functionality... ğŸ’¯

  ğŸ™ğŸ™ğŸ™ğŸ™ğŸ™ğŸ™ğŸ™ğŸ™ğŸ™ğŸ™ğŸ™ğŸ™ğŸ™ğŸ™ğŸ™ğŸ™ğŸ™ğŸ™ğŸ™ğŸ™ğŸ™ğŸ™ğŸ™ğŸ™ğŸ™ğŸ™ğŸ™ğŸ™ğŸ™ğŸ™ğŸ™ğŸ™ğŸ™ğŸ™ğŸ™ğŸ™
  but first -> Too Much Responsibility in One File (violates SRP - Single Responsibility Principle):

so, HomePage.js placed in folder(Homepage) (used in app.js (import HomePage from "./pages/Homepage/HomePage";))
and al-so, prevent any over-engineering..
and also, also,  no assumptions, no extras..

so for now, I am using a logic file (HomepageLogic.js) to abstract functionalityğŸ™ğŸ™ğŸ™ğŸ™ğŸ™
and and, moving All state + side effects to (HomepageLogic.js)ğŸ™ğŸ™ğŸ™ğŸ™ğŸ™

ğŸ“ So How to Organize It?
Currently Sticking with 2 files only..

File and their	Responsibility:
HomePage.js	Pure JSX + UI controls. Renders UI using data from logic hook.
HomepageLogic.js	Contains all useState, useEffect, sorting/filtering/pagination logic, and handler methods.

// and with that, something came to notice (the absence of a flag(append)ğŸ¤£)
|| SituationğŸ”´	             || append flagğŸ”µ	   || What happensğŸŸ¢ 
|| New filter/sort applied	  || false	          ||  Replace current products list
|| Load More clicked	        || true	            ||  Add to the existing products list

// so added++
// and now in HomePage.js (use HomepageLogic.js) && use that hook for importing and destructuring...
______________________________________________________________________________

______________________________________________________________________________
we had seen (many types of response)...
i.e
---------------------------------------------------------------------
âœ… Object Response (for single item)
{
  "success": true,
  "product": {
    "_id": "123",
    "name": "iPhone 14",
    "price": 799
  }
}
--------------------------------------------------------------------
âœ… Array Response (for simple lists)
[
  { "_id": "1", "name": "Mobiles" },
  { "_id": "2", "name": "Laptops" }
]
---------------------------------------------------------------------
âœ… Object with Array Inside (for filters, pagination, etc.)
{
  "success": true,
  "products": [
    { "_id": "1", "name": "iPhone 14", "price": 799 },
    { "_id": "2", "name": "Galaxy S22", "price": 699 }
  ],
  "page": 1,
  "total": 27
}
----------------------------------------------------------------------

After splitting home-page to sub-divisions, getting some error due to wrong destructuring or return format after the split.
âŒğŸ’
so we confirmed that backend response, and made changes acc. to that,and all set

Also, we learned CUSTOM HOOK creation(having prefix use)ğŸŒŸâœ¨ğŸ“ŒğŸ“ŒğŸ“ŒğŸ“ŒğŸ“ŒğŸ“ŒğŸ“ŒğŸ“ŒğŸ“ŒğŸ“Œ

//SO, we introduced a flag, so now,
âœ…. Ensure append: true is passed only when loading more

// A issue: abnormal behaviour,, not seen(so a bug)
// after sorting (from default to other) works, so user clicks load more(still works as intended so user carries on and reaches end of products so(load more invinsible)), but when user changes the sorting option(to something other, (load more becomes visible) and also that sorting works(as intended) but then load more failsğŸ’§ğŸ§¨...)
({["page not resets properly when sorting changes"]})

Sorting resets products, but page should reset too.ğŸ“ŒğŸ“ŒğŸ“ŒğŸ“ŒğŸ“ŒğŸ“ŒğŸ“Œ

âœ… On sort change â†’ setPage(1) and refetch.
âŒ If page stays 2 or 3 â†’ backend returns blank array on "Load More".
Always reset page = 1 when filters/sorts change.

// The fix: on sort Radio.onChange,,  setPage(1);
______________________________________________________________________________

______________________________________________________________________________
so, Before HomePage.js = UI + API + state + logicğŸ˜¬ğŸ˜… 
now, After HomePage.js = UI ğŸ˜ğŸ™‚

ğŸ“Œ(Hook = logic, state, API), here Hook = HomepageLogic.js ( // 1. All state,   // 2. All side effects,  // 3. All actions)

## HomepageLogic ####################################################################
export const useHomepageLogic = () => {
  return {
    products,
    categories,
    checked,
    setCategories,
    setChecked,
    setRadio,
    setPage,
    ....................... more than 20 
    ----------------------------------------------- F-E-E-D

## HomePage ##########################################################################
const {
    products,
    categories,
    checked,
    setCategories,
    setChecked,
    setRadio,
    setPage,
    ........................ more than 20
    ----------------------------------------------- F-E-T-C-H
    } = useHomepageLogic();

// ğŸ” empty dependency array [] means -> Run this once, after the first render â€” and never again.(in-dependent, won't rerun),,âœ…i.e in our case -> initial products loads once.

  useEffect(() => {
    getAllCategories(setCategories);
    getTotalCreatedProductsCount(setTotal);
  }, []);

//ğŸ” does NOT run on initial render unless dependencies is initially set to a diff. value during render(which usually it isnâ€™t). as these side-effect dependent on dependencies âœ…i.e in our case -> Filters and pagination fetch new data as needed.

  useEffect(() => {
   ......
  }, [page]);

  useEffect(() => {
   ......
  }, [checked,radio]);

ğŸ”¥ğŸ”¥NOTEğŸ”¥ğŸ”¥ Creation of useHomepageLogic is a classic application of Separation of Concerns (SoC) through custom React hooks.

// now moving to search functionality

// a little fact on chatGPT
currently our this doc > 12,000 words...

ChatGPT Single message limit:

âœ~32,000 tokens (for GPT-4-turbo, used in ChatGPT)

âœThis equals ~24,000â€“26,000 words, depending on the language and formatting

âœSo yes, your text (12,000 words approx) is within limits
// so double of our current doc, will go out of chatgpt current limits of (24,000 words, currently we have 12,000 words)

// and also, for ai (during coding), turn off - improve model for everyone(i.e equals leak data)
______________________________________________________________________________

______________________________________________________________________________
currently, besides the initial load useEffect, we have two useEffect calling same FUNCTION(but with varying dependencies)
so, merge them for fewer api endpoint hits, fewer renders (and increase performance on Products fetch)

But still why!
so, 
âœ… 1. Prevents race conditions and overlaps (& also avoids subtle edge cases.)
With separate effects:

Changing filters (checked, radio) triggers fresh fetch
Then, you change page, which triggers another fetch
=> Both may hit simultaneously or out-of-order.

âœ… 2. Centralizes logic and avoids repeated logic
The append logic is duplicated otherwise.

âœ… 3. Ensures consistent behavior regardless of change order
By using one effect watching [page, checked, radio], it doesn't matter which changed first â€” it recalculates with the latest data.

and also, as the useEffect merging(- support append flag:)

------------
ğŸ” Example Scenario (why merge the 2 useEffects having dependencies(calling same function))
Scenario: ###########################################################################################################
User selects a category (triggers 2nd useEffect) |||â„|||| While fetch is ongoing, user also clicks "Load More" (changes page)

Result: ###########################################################################################################
Separate useEffects => two overlapping API callsğŸ’€ |||â„|||| Combined version => only one effect runs, with latest values

 âœ… 1. Modify HomePage.js
 useEffect(() => {
  const append = page !== 1; // Append only when page > 1 ("Load More")   // page !== 1(on initial load, false)
  getFilteredProducts({
    checked,
    radio,
    page,
    sortRef,
    setProducts,
    setFilteredTotal,
    append,
  });
}, [checked, radio, page]);

This is straightforward:ğŸ’€ğŸ’€

If you're loading page 1     â†’ overwrite (append: false)ğŸ’€ğŸ’€
If you're loading page > 1   â†’ append (append: true)ğŸ’€ğŸ’€

âœ… 2. Update HomepageLogic.js
= async({..., append = false, }) => {
    try {
      let sortingObject = { createdAt: -1 };
      if (sortRef.current === "pricehightolow") sortingObject = { price: -1 };
      if (sortRef.current === "pricelowtohigh") sortingObject = { price: 1 };

      setLoading(true);
      const { data } = await axios.post( `${API}/api/v1/product/product-filters`,
        {  checked, radio, page, sortingObject, }
      );

      if (append) {
       // If append = true (correct) && // Load more â†’ Add to old list
        const newProducts = Array.isArray(data?.filteredProducts)   ? data.filteredProducts  : [];
        setProducts((prev) => [...prev, ...newProducts]);
      } else {
        console.log("Append:", append); // If append = false (correct) && // Filters/sort changed â†’ New list
        setProducts( Array.isArray(data?.filteredProducts) ? data.filteredProducts : [] );
      }

      if (setFilteredTotal) {
        setFilteredTotal(data?.filteredTotal || 0);
      }
      setLoading(false);
    } catch (err) {
      console.error("Error fetching filtered products:", err);
      setLoading(false);
    }
______________________________________________________________________________

______________________________________________________________________________

so we had âœ… 1. Modified HomePage.js && âœ… 2. Updated HomepageLogic.js
so now, ğŸ” on initial render?

Initial state of:
page = 1
checked = []
radio = []

So when component mounts:
useEffect([checked,radio,page]) fires once BECAUSE it sees VALUES.

Recap: ğŸ”  all useEffect hooks runs once on mount, no matter the dependencies.(BUT without array, on every RENDER )
useEffect(() => { ... }) â€” No dependency array
âš ï¸ Runs after every render, including the first one.

Use case: Rarely needed. Usually used when you need full control or intentionally want to react to every re-render (can affect performanceâŒ).

so, we merged (2 useEffect calling same function), Handle filters and pagination separately(now unity...)
âœ… Combine filter + pagination logic in a single useEffect([checked, radio, page])
âŒ Avoid setting setPage(1) inside a [checked, radio] effect â€” it causes double renders & fetches
âœ… Use append: page > 1 or similar to decide whether to replace or add products

ğŸƒnow continuing to the search functionality(keyword in either product name or product description)





